Feladat

Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik a double uploading(double up_bl[]), amely 6 db negatív lebegőpontos számot kér be úgy,
hogy azokat egy tömbbe tárolja le (1. paraméter). A tömb hosszát szimbolikus állandóval állítsa be.
A tárolás csak akkor jöjjön létre, ha a szám -10-nél nagyobb!
Ha az adott érték nem teljesíti a rá vonatkozó feltételeket, akkor helyette új számot kell bekérni.
A bekérési folyamatnak addig kell folytatódnia, amíg a tömb teljes feltöltése meg nem történik.
Bekérési információk és hibaüzenetek kiírása nem kell!

A feltételek teljesülése esetén az uploading nevű függvény határozza meg a tömbbe letárolt értékek
harmadik hatványainak a különbségét.
(Azaz, az 1. szám hatványából vonja ki a 2. szám hatványát, majd ebből a 3. szám hatványát és így tovább.)
Ezek után ezzel a számmal térjen vissza (visszatérési érték).
A különbség tizedespontosságának a meghatározását bízza a fordítóra.

A másik függvény a void writesOut(double diff), pedig írja ki, hogy a uploading nevű függvény
visszatérési értékének (amit az 1. paraméterben vesz át) egész része, hány számjegyű.
A kiírás a példában látott tagolással és szövegezéssel történjen.
For example:
Input
Result
-10.1 -10 -3.2 -2.1 0.0 1.1 -1.4 -1.5 -2.2 -1.14
Egyjegyű: -5.25846
-10.1 -10 -3.2 -2.1 0.0 1.1  -1.4 -1.5 -2.2 -3.14
Kétjegyű: 24.2191
-10.1 -10 -9.2 -2.1 0.0 1.1  -1.4 -1.5 -2.2 -1.14
Több mint kétjegyű: -751.178

Feladat
Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik az int charLoad(char c_bk[]), amely feltölt egy karakter tömböt (1. paraméter)
ékezet nélküli betűkkel az ENTER billentyű leütéséig, vagy maximum 256 db karakterig.
Bekérési információk és hibaüzenetek kiírása nem kell! A tömb hosszát szimbolikus állandóval állítsa be.
A függvény visszatérési értéke a feltöltött tömb hossza legyen.

A másik függvény a void change(char up_bl[], int lg), pedig a feltöltött tömb (1. paraméter),
kisbetűit cserélje le a nagybetűs alakjára.
Ezek után a fentiek szerint módosított tömb tartalmát írja is ki.
Továbbá a következő sorban jelenítse meg, hogy az eredeti tömbben hány db nagybetű volt,
a példában látott tagolással és szövegezéssel.
A change nevű függvény 2. paramétere a charLoad függvény visszatérési értéke.
For example:
Input
Result
aLmA KoRtE DiNnYeK
ALMA KORTE DINNYEK
Eredeti: 9
CSAK NAGYBETUS SZAVAKBOL ALL
CSAK NAGYBETUS SZAVAKBOL ALL
Eredeti: 25
kisbetus bemenet
KISBETUS BEMENET
Eredeti: 0

Feladat
Egy adat-file első sorában csak egy pozitív egész szám található, amely a további sorok számát jelenti, amelyek egy-egy futócipő márkát azonosítanak a következők szerint:
            Márkanév  1._szín  2._szín  3._szín
Az adatokat szóközök választják el egymástól! Pl.:
             Adidas  blue  yellow  gray
             …
             Nike  red  green  white
Írjon egy int colorSearch(string fbe, string *brand) függvényt, amelynek a visszatérési értéke
azt mutatja meg, hogy összesen hány márkának van green színű cipője az 1. paraméterben megadott
adatállományban.

Ezen állomány létezését ellenőrizni kell! Ha az adat-file nem létezik, akkor a "Sikertelen file-nyitás!" karaktersorozat
is jelenjen meg a monitoron! A hibaüzenet formátumát a példa is mutatja! (Ekkor a márkák száma természetesen nulla!)

Az adat-file elemeit tárolja el egy struktúra-tömbbe, amihez használja a megadott struct running_shoes típust!
A struktúra-tömböt a dinamikus memóriába hozza létre!
Ha az adott márkának létezik green színű cipője, akkor a bool color_green változóba az igaz, ha nem létezik,
akkor a hamis érték kerüljön. Ezek összegzése legyen a visszatérési érték!

A 2. paraméterben a függvény pedig adja vissza annak a márkának a nevét, amelyik az adatállomány utolsó
sorában található.
For example:
Test
Result
string br;
std::cout << colorSearch("Shoes.txt", &br) << "\n" << br << endl;
2
Saucony
string br;
std::cout << colorSearch("NoShoes.txt", &br) << "\n" << br << endl;
Sikertelen file-nyitás!
0

Feladat
Írjon egy string* fullNameSort(string fbe, string fki) függvényt, amely kiírja az alábbi
rendezésen átesett szerzők neveit egy kimeneti-file-ba (2. paraméter). Továbbá a visszatérési értéke, az a dinamikus tömb legyen, amely tartalmazza a rendezéseket.
A szerzők vezetéknevét és keresztneveit (több is lehet) egy adat-file (1. paraméter) tartalmazza úgy,
hogy a nevek a katalogizálás szabályait követik. Azaz a vezetéknév után van egy vessző,
egy szóköz, majd következnek a keresztnevek szintén 1-1 szóközzel elválasztva.
Tehát így:
            vezetéknév,  1._keresztnév  2._keresztnév  …  n._keresztnév
  Pl.:
            Adams, Douglas Noel
            …
            Zahn, Timothy

Az adat-file elérhetőségét ellenőrizni kell, ha nem nyitható meg, akkor a képernyőn
a "Sikertelen file-nyitás!" karaktersorozat legyen olvasható!
Ha pedig a kimeneti-file-t nem lehet létrehozni, akkor a "Háttértár hiba!" karaktersorozat íródjon ki a monitorra!

Továbbá, ezen állomány első sorában csak egy pozitív egész szám található, amely az írók számát adja meg, amíg a további sorok egy-egy szerzőt azonosítanak a fent leírtak alapján.
Az adat-file szerző-sorait tárolja el egy dinamikus tömbbe (visszatérési érték)!

Ezek után alakítsa át ezen tömb tartalmát úgy, hogy a szerzők a teljes nevükre nézve
ABC sorrendbe legyenek rendezve.
For example:
Test
Result
string* szerzok=fullNameSort("Writers_sort.txt","Sretirw.txt");
if(szerzok) {
   for(int i=0; i<8; i++) { cout << szerzok[i] << endl; }
   delete [] szerzok; szerzok=0; }


Asimoa, Isaac\r
Asimov, Isaac\r
Bradbury, Ray Douglas\r
Clarke, Arthur Charle\r
Clarke, Arthur Charles\r
King, Stephen Edwin\r
Tolkien, John Ronald Reuel\r
Zahn, Timothy\r
string* szerzok=fullNameSort("NoWriters_sort.txt","Sretirw.txt");
if(szerzok) {
   for(int i=0; i<8; i++) { cout << szerzok[i] << endl; }
   delete [] szerzok; szerzok=0; }
Sikertelen file-nyitá

Feladat:
Írjon egy double** sinTetel(string fbe) függvényt, amelynek a visszatérési értéke egy
5 x 3-as dinamikus mátrix, amely 5 db általános háromszög 2 db szögét és 1 db oldalát tartalmazza, a lenti meghatározások alapján.
A háromszögek 3. oldalának és a további 2 szögének a kiszámításához szükséges adatokat egy adat-file tartalmazza, amelynek a létezését ellenőrizni kell! A hibaüzenet formátumát a példa is mutatja!
Ennek az állománynak az azonosítója lesz, a sinTetel nevű függvény paramétere.
Az adat-file egy-egy sora egy általános háromszög három adatát tartalmazza, ezek:
            az_1._oldal_(b)  a_2._oldal_(a)  a_2._oldallal_szembeni_szög_fokban_(alfa)
Az adatokat szóköz választja el egymástól! Pl.:
            40 80 30
            . . .              
            40 70 45

Az adat-file soronkénti elemeit szintén egy 5 x 3-as dinamikus mátrixba tárolja el
és ezen adatokból számítsa ki a 3. oldalt (c) és a maradék kettő szöget (beta, gamma) az ábrán is látható képletek segítségével:
    beta =  asin(b / a * sin(alfa * M_PI / 180)) / M_PI * 180


    gamma = 180 - alfa - beta
    c = sin(gamma * M_PI / 180) / sin(alfa * M_PI / 180) * a
A szögeket (beta, gamma) és a 3. oldalt ebben a sorrendben kell tárolni a visszatérési értékként kezelt double mátrixban!
A dinamikus mátrixok méreteit szimbolikus állandókkal állítsa be.
A szögek és a 3. oldal tizedespontosságának a meghatározását bízza a fordítóra.
Ha az adat-file nem létezik, akkor a monitoron a "Sikertelen file-nyitás!" karaktersorozat jelenjen meg!
For example:
Test
Result
double** szkb=sinTetel("Bfk_alfa.txt");
if(szkb) {
 for(int i=0; i<5; i++) {
   cout << szkb[i][0] << " " << szkb[i][1] << " " << szkb[i][2] << endl; }
 for(int i=0; i<5; i++) { delete [] szkb[i]; }
 delete [] szkb; szkb=0; }
14.4775 135.522 56.0503
41.6156 53.3844 32.2288
60 60 40
23.8323 111.168 52.7517
53.1301 36.8699 24
double** szkb=sinTetel("NoBfk_alfa.txt");
if(szkb) {
 for(int i=0; i<5; i++) {
   cout << szkb[i][0] << " " << szkb[i][1] << " " << szkb[i][2] << endl; }
 for(int i=0; i<5; i++) { delete [] szkb[i]; }
 delete [] szkb; szkb=0; }
Sikertelen file-nyitás!

Feladat
Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik a double uploading(double up_bl[]), amely 6 db negatív lebegőpontos számot kér be úgy,
hogy azokat egy tömbbe tárolja le (1. paraméter). A tömb hosszát szimbolikus állandóval állítsa be.
A tárolás csak akkor jöjjön létre, ha a szám -10-nél nagyobb!
Ha az adott érték nem teljesíti a rá vonatkozó feltételeket, akkor helyette új számot kell bekérni.
A bekérési folyamatnak addig kell folytatódnia, amíg a tömb teljes feltöltése meg nem történik.
Bekérési információk és hibaüzenetek kiírása nem kell!

A feltételek teljesülése esetén az uploading nevű függvény határozza meg a tömbbe letárolt értékek
harmadik hatványainak a különbségét.
(Azaz, az 1. szám hatványából vonja ki a 2. szám hatványát, majd ebből a 3. szám hatványát és így tovább.)
Ezek után ezzel a számmal térjen vissza (visszatérési érték).
A különbség tizedespontosságának a meghatározását bízza a fordítóra.

A másik függvény a void writesOut(double diff), pedig írja ki, hogy a uploading nevű függvény
visszatérési értékének (amit az 1. paraméterben vesz át) egész része, hány számjegyű.
A kiírás a példában látott tagolással és szövegezéssel történjen.

For example:

Input	Result
-10.1 -10 -3.2 -2.1 0.0 1.1 -1.4 -1.5 -2.2 -1.14
Egyjegyű: -5.25846
-10.1 -10 -3.2 -2.1 0.0 1.1  -1.4 -1.5 -2.2 -3.14
Kétjegyű: 24.2191
-10.1 -10 -9.2 -2.1 0.0 1.1  -1.4 -1.5 -2.2 -1.14
Több mint kétjegyű: -751.178

Feladat
Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik az int charLoad(char c_bk[]), amely feltölt egy karakter tömböt (1. paraméter)
ékezet nélküli betűkkel az ENTER billentyű leütéséig, vagy maximum 256 db karakterig.
Bekérési információk és hibaüzenetek kiírása nem kell! A tömb hosszát szimbolikus állandóval állítsa be.
A függvény visszatérési értéke a feltöltött tömb hossza legyen.

A másik függvény a void change(char up_bl[], int lg), pedig a feltöltött tömb (1. paraméter),
kisbetűit cserélje le a nagybetűs alakjára.
Ezek után a fentiek szerint módosított tömb tartalmát írja is ki.
Továbbá a következő sorban jelenítse meg, hogy az eredeti tömbben hány db nagybetű volt,
a példában látott tagolással és szövegezéssel.
A change nevű függvény 2. paramétere a charLoad függvény visszatérési értéke.

For example:

Input	Result
aLmA KoRtE DiNnYeK
ALMA KORTE DINNYEK
Eredeti: 9
CSAK NAGYBETUS SZAVAKBOL ALL
CSAK NAGYBETUS SZAVAKBOL ALL
Eredeti: 25
kisbetus bemenet
KISBETUS BEMENET
Eredeti: 0


Feladat
Írjon egy string* fullNameSort(string fbe, string fki) függvényt, amely kiírja az alábbi
rendezésen átesett szerzők neveit egy kimeneti-file-ba (2. paraméter).
Továbbá a visszatérési értéke, az a dinamikus tömb legyen, amely tartalmazza a rendezéseket.

A szerzők vezetéknevét és keresztneveit (több is lehet) egy adat-file (1. paraméter) tartalmazza úgy,
hogy a nevek a katalogizálás szabályait követik. Azaz a vezetéknév után van egy vessző,
egy szóköz, majd következnek a keresztnevek szintén 1-1 szóközzel elválasztva.
Tehát így:
            vezetéknév,  1._keresztnév  2._keresztnév  …  n._keresztnév
  Pl.:
            Adams, Douglas Noel
            …
            Zahn, Timothy

Az adat-file elérhetőségét ellenőrizni kell, ha nem nyitható meg, akkor a képernyőn
a "Sikertelen file-nyitás!" karaktersorozat legyen olvasható!
Ha pedig a kimeneti-file-t nem lehet létrehozni, akkor
a "Háttértár hiba!" karaktersorozat íródjon ki a monitorra!

Továbbá, ezen állomány első sorában csak egy pozitív egész szám található, amely az írók számát
adja meg, amíg a további sorok egy-egy szerzőt azonosítanak a fent leírtak alapján.
Az adat-file szerző-sorait tárolja el egy dinamikus tömbbe (visszatérési érték)!

Ezek után alakítsa át ezen tömb tartalmát úgy, hogy a szerzők a teljes nevükre nézve
ABC sorrendbe legyenek rendezve.

For example:

Test	Result
string* szerzok=fullNameSort("Writers_sort.txt","Sretirw.txt");
if(szerzok) {
   for(int i=0; i<8; i++) { cout << szerzok[i] << endl; }
   delete [] szerzok; szerzok=0; }
Asimoa, Isaac\r
Asimov, Isaac\r
Bradbury, Ray Douglas\r
Clarke, Arthur Charle\r
Clarke, Arthur Charles\r
King, Stephen Edwin\r
Tolkien, John Ronald Reuel\r
Zahn, Timothy\r
string* szerzok=fullNameSort("NoWriters_sort.txt","Sretirw.txt");
if(szerzok) {
   for(int i=0; i<8; i++) { cout << szerzok[i] << endl; }
   delete [] szerzok; szerzok=0; }
Sikertelen file-nyitás!


Feladat
Írjon egy double** sinTetel(string fbe) függvényt, amelynek a visszatérési értéke egy
5 x 3-as dinamikus mátrix, amely 5 db általános háromszög 2 db szögét és 1 db oldalát tartalmazza,
a lenti meghatározások alapján.

A háromszögek 3. oldalának és a további 2 szögének a kiszámításához szükséges adatokat egy
adat-file tartalmazza, amelynek a létezését ellenőrizni kell! A hibaüzenet formátumát a példa is mutatja!
Ennek az állománynak az azonosítója lesz, a sinTetel nevű függvény paramétere.
Az adat-file egy-egy sora egy általános háromszög három adatát tartalmazza, ezek:
            az_1._oldal_(b)  a_2._oldal_(a)  a_2._oldallal_szembeni_szög_fokban_(alfa)
Az adatokat szóköz választja el egymástól! Pl.:
            40 80 30
            . . .              
            40 70 45

Az adat-file soronkénti elemeit szintén egy 5 x 3-as dinamikus mátrixba tárolja el
és ezen adatokból számítsa ki a 3. oldalt (c) és a maradék kettő szöget (beta, gamma) az ábrán
is látható képletek segítségével:
    beta =  asin(b / a * sin(alfa * M_PI / 180)) / M_PI * 180
    gamma = 180 - alfa - beta
    c = sin(gamma * M_PI / 180) / sin(alfa * M_PI / 180) * a

A szögeket (beta, gamma) és a 3. oldalt ebben a sorrendben kell tárolni
a visszatérési értékként kezelt double mátrixban!
A dinamikus mátrixok méreteit szimbolikus állandókkal állítsa be.
A szögek és a 3. oldal tizedespontosságának a meghatározását bízza a fordítóra.

Ha az adat-file nem létezik, akkor a monitoron a "Sikertelen file-nyitás!" karaktersorozat jelenjen meg!

For example:

Test	Result
double** szkb=sinTetel("Bfk_alfa.txt");
if(szkb) {
 for(int i=0; i<5; i++) {
   cout << szkb[i][0] << " " << szkb[i][1] << " " << szkb[i][2] << endl; }
 for(int i=0; i<5; i++) { delete [] szkb[i]; }
 delete [] szkb; szkb=0; }
14.4775 135.522 56.0503
41.6156 53.3844 32.2288
60 60 40
23.8323 111.168 52.7517
53.1301 36.8699 24
double** szkb=sinTetel("NoBfk_alfa.txt");
if(szkb) {
 for(int i=0; i<5; i++) {
   cout << szkb[i][0] << " " << szkb[i][1] << " " << szkb[i][2] << endl; }
 for(int i=0; i<5; i++) { delete [] szkb[i]; }
 delete [] szkb; szkb=0; }
Sikertelen file-nyitás!

Feladat
Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik a double infuse(double in_bk[]), amely 5 db pozitív lebegőpontos számot kér be úgy,
hogy azokat egy tömbbe tárolja le (1. paraméter). A tömb hosszát szimbolikus állandóval állítsa be.
A tárolás csak akkor jöjjön létre, ha a szám 256-nál kisebb!
Ha az adott érték nem teljesíti a rá vonatkozó feltételeket, akkor helyette új számot kell bekérni.
A bekérési folyamatnak addig kell folytatódnia, amíg a tömb teljes feltöltése meg nem történik.
Bekérési információk és hibaüzenetek kiírása nem kell!

A feltételek teljesülése esetén az infuse nevű függvény határozza meg a tömbbe letárolt értékek
harmadik gyökeinek a szorzatát.
(Azaz, az 1. szám gyökét szorozza meg a 2. szám gyökével, majd ezt a 3. szám gyökével és így tovább.)
Ezek után ezzel a számmal térjen vissza (visszatérési érték).
A különbség tizedespontosságának a meghatározását bízza a fordítóra.

A másik függvény a void outwrite(double root), pedig írja ki, hogy a infuse nevű függvény
visszatérési értékének (amit az 1. paraméterben vesz át) egész része, páros vagy páratlan.
A kiírás a példában látott tagolással és szövegezéssel történjen.

Feladat
Írjon egy programot, amely 2 db felhasználói függvényt használ.

Az egyik az int loadText(char t_bk[]), amely feltölt egy karakter tömböt (1. paraméter)
ékezet nélküli betűkkel a '#' (hashtag) karakterig.
Bekérési információk és hibaüzenetek kiírása nem kell!
A tömb 128 karakter fogadására legyen képes, a hosszát szimbolikus állandóval állítsa be.
A függvény visszatérési értéke a feltöltött tömb hossza legyen.

A másik függvény a void upperNumber(char un_bl[], int lm), pedig a feltöltött tömb (1. paraméter),
nagybetűit cserélje le számokra, amelyek nullától növekednek egyesével.
(Azaz, az 1. nagybetűt cserélje 0-ra, a 2. nagybetűt 1-re és így tovább.)
Ezek után a fentiek szerint módosított tömb tartalmát írja is ki, a '#' nélkül!
Továbbá a következő sorban jelenítse meg, hogy az eredeti tömbben hány db nagybetű volt,
a példában látott tagolással és szövegezéssel.
A upperNumber nevű függvény 2. paramétere a loadText függvény visszatérési értéke.

Feladat
Egy adat-file első sorában csak egy pozitív egész szám található, amely a további sorok számát jelenti,
amelyek egy-egy bringás cipő márkát azonosítanak a következők szerint:
            Márkanév  alsó_mérethatár  felső_mérethatár
Az adatokat szóközök választják el egymástól! Pl.:
             Sidi  40.5  45.5
             …
             Shimano  35.75  40.25

Írjon egy int sizeSearch(string fbe, double my_size, string *brand) függvényt, amelynek a visszatérési értéke
azt mutatja meg, hogy összesen hány márkából nem tudnánk cipőt választani, az 1. paraméterben megadott
adatállomány alapján.
A számunkra szükséges méretet a 2. paraméter tartalmazza.

Ezen állomány létezését ellenőrizni kell! Ha az adat-file nem létezik, akkor a "Sikertelen file-nyitás!" karaktersorozat
is jelenjen meg a monitoron! A hibaüzenet formátumát a példa is mutatja! (Ekkor a márkák száma természetesen nulla!)

Az adat-file elemeit tárolja el egy struktúra-tömbbe, amihez használja a megadott struct bike_shoes típust!
A struktúra-tömböt a dinamikus memóriába hozza létre!
Ha az adott márkának létezik számunkra megfelelő méretű cipője, akkor a bool size_OK változóba az igaz,
ha nem létezik, akkor a hamis érték kerüljön. Ezek összegzésének a komplementere (ellentettje) legyen a visszatérési érték!
(Komplementer halmaz = kiegészítő halmaz a teljes halmazra nézve.)

Feladat
Írjon egy string* lastLetterSort(string fbe, string fki) függvényt, amely kiírja az alábbi
rendezésen átesett szerzők neveit egy kimeneti-file-ba (2. paraméter).
Továbbá a visszatérési értéke, az a dinamikus tömb legyen, amely tartalmazza a rendezéseket.

A szerzők vezetéknevét és keresztneveit (több is lehet) egy adat-file (1. paraméter) tartalmazza úgy,
hogy a nevek a katalogizálás szabályait követik. Azaz a vezetéknév után van egy vessző,
egy szóköz, majd következnek a keresztnevek szintén 1-1 szóközzel elválasztva.
Tehát így:
            vezetéknév,  1._keresztnév  2._keresztnév  …  n._keresztnév
  Pl.:
            Adams, Douglas Noel
            …
            Zahn, Timothy

Az adat-file elérhetőségét ellenőrizni kell, ha nem nyitható meg, akkor a képernyőn
a "Sikertelen file-nyitás!" karaktersorozat legyen olvasható!
Ha pedig a kimeneti-file-t nem lehet létrehozni, akkor
a "Háttértár hiba!" karaktersorozat íródjon ki a monitorra!

Továbbá, ezen állomány első sorában csak egy pozitív egész szám található, amely az írók számát
adja meg, amíg a további sorok egy-egy szerzőt azonosítanak a fent leírtak alapján.
Az adat-file szerző-sorait tárolja el egy dinamikus tömbbe (visszatérési érték)!

Ezek után alakítsa át ezen tömb tartalmát úgy, hogy a szerzők a teljes nevük utolsó karakterére nézve
fordított ABC sorrendbe legyenek rendezve úgy, hogy a szerzők teljes nevei is visszafelé legyenek letárolva.

Feladat
Írjon egy double** cosTetel(string fbe) függvényt, amelynek a visszatérési értéke egy
5 x 3-as dinamikus mátrix, amely 5 db általános háromszög 1 db oldalát és 2 db szögét és  tartalmazza,
a lenti meghatározások alapján.

A háromszögek 3. oldalának és a további 2 szögének a kiszámításához szükséges adatokat egy
adat-file tartalmazza, amelynek a létezését ellenőrizni kell! A hibaüzenet formátumát a példa is mutatja!
Ennek az állománynak az azonosítója lesz, a cosTetel nevű függvény paramétere.
Az adat-file egy-egy sora egy általános háromszög három adatát tartalmazza, ezek:
            az_1._oldal_(b)  a_2._oldal_(a)  ezen_oldalak_közötti_szög_fokban_(gamma)
Az adatokat szóköz választja el egymástól! Pl.:
            40 80 30
            . . .              
            40 70 45

Az adat-file soronkénti elemeit szintén egy 5 x 3-as dinamikus mátrixba tárolja el
és ezen adatokból számítsa ki a 3. oldalt (c) és a maradék kettő szöget (beta, alfa) az ábrán
is látható képletek segítségével:
    c = sqrt(a*a + b*b - 2 * a * b * cos(gamma * M_PI / 180))
    beta =  asin(b / c * sin(gamma * M_PI / 180)) / M_PI * 180
    alfa = 180 - gamma - beta

A 3. oldalt (c) és a szögeket (beta, alfa) ebben a sorrendben kell tárolni
a visszatérési értékként kezelt double mátrixban!
A dinamikus mátrixok méreteit szimbolikus állandókkal állítsa be.
A 3. oldal és a szögek tizedespontosságának a meghatározását bízza a fordítóra.

Ha az adat-file nem létezik, akkor a monitoron a "Sikertelen file-nyitás!" karaktersorozat jelenjen meg!

Feladat
Definiálja azt a void decode(std::string s) függvényt, ami kikódolva a szabvány kimenetre írja az s karakterlánc tartalmát! A kikódolás abból áll, hogy a karakterláncban szereplő számjegy karaktereket követő egy-egy karaktert pontosan a számjeggyel meghatározott alkalommal ismételve nyomtatja a kimenetre. Amelyik jel előtt nem áll számjegy karakter, azt változtatás nélkül, egyszer kell nyomtatni.

Feladat
Definiálja azt a void duration(std::string fileName) függvényt, ami megnyitja a fileName nevű CSV fájlt, melynek első sora fejléc, nem hordoz felhasználható információt, ezért át kell ugrani. A második sortól kezdődően minden sor két cellából áll, melyeket vessző (,) karakter választ el egymástól. A cellák ÓÓ:PP formátumban megadott időpontok egy napon belül. Feltételezheti, hogy az első korábbi, mint a második. Számolja ki minden sorra a két időpont közötti különbséget percekben mérve, és külön sorokban nyomtassa ki a szabvány kimenetre!

Tájékoztatásul, az ido1.csv tartalma a következő:

start,end
06:52,07:29
11:23,11:24
22:01,23:59
13:49,13:55
17:31,17:31
12:34,15:16
08:41,09:11

Feladat
Definiálja azt a void manhattan(int mtx[][COLS], int rows) függvényt, ami a paraméterként kapott mtx mátrix minden cellájába beírja annak bal felső cellájától mért Manhattan-távolságát, azaz azt, hogy hány jobbra és/vagy lefelé lépéssel lehet az adott cellába eljutni a bal felső saroktól. A mátrix rows sorból és COLS oszlopból áll.

Feladat
Definiálja azt az int** snail(int size) függvényt, amely létrehoz egy size x size méretű dinamikus mátrixot, majd a bal felső sarkától elindulva az óramutató járásával megegyező irányban, csigavonalban haladva 1-től kezdődően rendre egyesével növekvő számokat ír mindaddig, amíg az összes mezőt ki nem töltötte! A visszatérési érték a kitöltött mátrix (vektorokat címző mutatótömb).

Feladat
Definiálja azt a double surface(double r, double h) függvényt, ami visszaadja az r sugarú, h magasságú egyenes, kör alapú kúp felszínét! Használja a matematikai függvénykönyvtárat pi értékének meghatározásához!

Kúp felszíne

For example:

Test	Result
std::cout << surface(1., 1.) << std::endl;
7.58448

Feladat
Definiálja azt a void manhattan(int mtx[][COLS], int rows) függvényt, ami a paraméterként kapott mtx mátrix minden cellájába beírja annak bal felső cellájától mért Manhattan-távolságát, azaz azt, hogy hány jobbra és/vagy lefelé lépéssel lehet az adott cellába eljutni a bal felső saroktól. A mátrix rows sorból és COLS oszlopból áll.

For example:

Test	Result
int m2[2][COLS];
manhattan(m2, 2);
print(m2, 2);
  0  1  2  3  4
  1  2  3  4  5

Feladat
Definiálja azt az int parity(int data) függvényt, melynek visszatérési értéke 0, ha a data-ban szereplő 1-es értékű bitek száma páros, és 1, ha páratlan!

For example:

Test	Result
std::cout << parity(1+2) << std::endl;
0
std::cout << parity(4) << std::endl;
1

Feladat
Definiálja azt az int** snail(int size) függvényt, amely létrehoz egy size x size méretű dinamikus mátrixot, majd a bal felső sarkától elindulva az óramutató járásával megegyező irányban, csigavonalban haladva 1-től kezdődően rendre egyesével növekvő számokat ír mindaddig, amíg az összes mezőt ki nem töltötte! A visszatérési érték a kitöltött mátrix (vektorokat címző mutatótömb).

For example:

Test	Result
int** m5 = snail(5);
print(m5, 5);
freemem(m5, 5);
 1  2  3  4  5
16 17 18 19  6
15 24 25 20  7
14 23 22 21  8
13 12 11 10  9

Feladat
A JPEG tömörítésnek van egy olyan lépése, amikor egy négyzetes mátrixban lévő számokat adott sorrendben járják végig, és írják egymás után. A bejárás olyan, mintha egy tollal húzott egyetlen vonallal kellene összekötni a bal felső sarokból indulva valamennyi számot úgy, hogy mindig átlós irányokban próbáljunk haladni (l. az alábbi mintát).

Kvantált együtthatók bejárási sorrendje

Definiálja azt az int* mtx2vec(int** mtx, int n) függvényt, ami a fenti mintának megfelelő sorrendben végigjárja az n sorból és oszlopból álló mtx négyzetes mátrix elemeit, és egy dinamikusan létrehozott, azonos elemszámú vektorba írja azokat. Ez utóbbi címe a visszatérési érték. Az mtx technikailag int* mutatók tömbje.

Feladat
Hozzon létre bool palindrome(string str) függvényt, ahol str egy bemeneti, csak az angol ábécé kisbetűit tartalmaző szöveg, amelyről el kell dönteni, hogy palindrom vagy sem. Ha str palindrom, akkor a függvény igaz értékkel, máskülönben hamis értékkel térjen vissza.
Döntse el egy szövegről, hogy palindrom vagy sem! Akkor nevezzünk egy szöveget palindromnak, ha visszafele olvasva, karakterről karakterre ugyanazt a szöveget kapjuk.

Feladat
Készítsen void printChord(struct chord c) amely képes gitár akkordot tabulatúra lejegyzésben megjeleníteni.

Legyen struct chord egy olyan struktúra amely egy akkord esetén tartalmazza:

Az egyes húrok hangolását (alaphangját), ami egy-egy karakter. (char tune[6])
Minden húr esetén, hogy hányadik érintőn (bund-on) kell lefogni. A legelső érintő sorszáma 1, a legutolsó legyen 24. Ha üresen (lefogás nélkül) kell megszólaltatni a húrt, akkor értéke 0. Ha nem kell megszólaltatni a húrt, akkor értéke -1. (int fret[6])
Valamint, hogy az adott húrt melyik ujjal kell lefogni a megadott érintőn. Ennek értéke minimum 1 és maximum 4 (mutatóujj, középső ujj, gyűrűsujj és kisujj szerinti sorrendben), kivéve, ha az adott húrt nem kell megszólaltatni vagy üresen kell megszólaltatni. Ebben a két esetben értéke -1. (int finger[6])
A printChord függvény a következő minta szerint rajzolja a kimenetre a bemenetként kapott akkordot. Minden egyes sor, egy húrnak a leírása. Az 1. sor a tune[0] hangolású, fret[0] bundon, finger[0] ujjal lefogott hangot mutatja, és így tovább. Ebben az esetben csak 6 húros gitárokra kell felkészülni.

Minden sorban az első karakter legyen az adott húr hangolása, amit egy szóköz követ. Utána, ha az adott húrt üresen kell megszólaltatni, akkor egy "O" karakter következik. Ha nem kell megszólaltatni, akkor "X" karakter következik. Ha lefogással kell megszólaltatni, akkor még egy szóköz következik.

Ez után következik a lefogások vizualizálása. Két "|" karakter közötti területet tekintünk két érintő közötti területnek. Ha a kitöltés három "-" karakter, akkor az adott érintőnél nem kell lefogni a húrt. Ahol a húrt le kell fogni, ott két "-" karakter között az ujj sorszámát tüntetjük fel.

A megjelenítés során csak annyi érintőközt jelenítünk meg, amennyire szükség van és az utolsó sorban jelezzük, hogy a legelső hányadik érintőt jelenti. A szükséges érintő közök számát úgy kaphatjuk meg, ha a fret tömb pozitív értékeinek maximuma és minimumának a különbségéhez 1-et hozzáadunk.

For example:

Test	Result
struct chord c = {{'e', 'b', 'g', 'd', 'a', 'e'}, {-1, 7, 5, 4, 5, -1}, {-1, 4, 3, 1, 2, -1}};
printChord(c);
e X|---|---|---|---|
b  |---|---|---|-4-|
g  |---|-3-|---|---|
d  |-1-|---|---|---|
a  |---|-2-|---|---|
e X|---|---|---|---|
     4
struct chord c = {{'e', 'b', 'g', 'd', 'a', 'e'}, {0, 1, 2, 2, 0, -1}, {-1, 1, 3, 2, -1, -1}};
printChord(c);
e O|---|---|
b  |-1-|---|
g  |---|-3-|
d  |---|-2-|
a O|---|---|
e X|---|---|

Feladat
Készítsen string getFirstCurse(struct curse curses[], int n) függvényt. A curses tömb minden eleme 1-1 káromkodást tartalmaz Quentin Tarantino valamely filmjéből. Egy káromkodáshoz (struct curse) tartozik a film címe, amiben elhangzott, a káromkodás szövege, valamint annak ideje a filmben. Az n változó megadja, hogy a bemeneti curses tömb hány bejegyzést tartalmaz. A függvény keresse meg, hogy melyik káromkodás hangzott el leghamarabb. Visszatérési értéke legyen a leghamarabbi káromkodáshoz tartozó film címe. Készítse el a káromkodások tárolására alkalmas struktúrát is. Egy movie nevű, string típusú változó tárolja a film címét, amiben elhangzik a káromkodás. A káromkodás szintén string típusú és a word nevet viseli. Végül egy dupla pontosságú lebegőpontos változóban, mely a time nevet hordja, tárolja el a káromkodás elhangzásának idejét.

Feladat
Adott a point, polygon és circle struktúrák. Egy point meghatároz egy síkbeli pontot az x és y tagjával. Egy polygon leír egy síkbeli poligont, ahol pts tömb a poligonhoz tartozó egymás utáni pontokat jelöli, a numOfPoints tagja pedig a poligonhoz tartozó pontok számát tárolja. Egy circle megad egy kört a síkon annak középpontjával (center adattag) és sugarával (radius adattag).

Készítsen struct circle enclosingCircle(struct polygon p) függvényt, amely meghatároz a paraméterül kapott p poligonhoz egy befoglaló kört a következő szerint. A keresett kör középpontját a poligon pontjainak átlaga adja. A kör sugarát a kör középpontjának és a poligon azon pontjának a távolsága adja, mely pontja a legtávolabb esik a kör középpontjától.

Feladat
Készítsen void isFart(string dataset) függvényt, ahol dataset egy csv formátumú fájl neve, melynek első oszlopa egy állat nevét, második oszlopa pedig annak a tényét tartalmazza, hogy az adott állat, megfigyelések alapján, szokott e a végbélnyílásán keresztül bélgázt ereszteni. Ennek értéke a következők valamelyike lehet: No, Maybe, Yes, Hell Yes. A fájlban a két tulajdonság pontosvesszővel van elválasztva egymástól. A függvény írja a kimenetre azon állatok nevét, melyek biztosan szoktak bélgázt ereszteni, azaz ennek értéke vagy "Yes", vagy "Hell Yes". A kiírás során az állatok nevét egy sorba, egymástól pontosvesszővel elválasztva jelenítse meg.

Részlet egy lehetséges bemeneti csv fájlból:

Baboons;Yes
Bristle worms;No
Giraffe;Hell Yes
Spiders;Maybe
     1




bool palindrome(string str) {
	bool az = false;
	int hossz;
	hossz = str.length();
	for (int i = 0; i < hossz; i++) {
		for (int j = hossz; j >= 0; j--) {
			if (str[i] == str[j]) { 
				az = true;
			}
			else { 
				az = false;}
		}
	}
	return az;
}

Feladat
Készítsen string getNotes(string chord) függvényt, ami egy paraméterül kapott akkord nevéről eldönti, hogy milyen hangokból épül fel és ezeket egy string - be fűzve, szóközzel elválasztva visszaadja.A zenei hangok sorban a következők lehetnek : "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#" vagy "B".A hangok sorban egymást követik, olyan módon, hogy a "B" hang után ismét "C" következik, majd "C#", és így tovább.A függvénynek két fajta akkordot kell felismernie : dúr akkord és domináns szeptimakkord.A dúr akkord neve csak az alaphangjából áll, ami tetszőleges hang lehet a felsoroltak közül.Például : "A", "C#" stb.A domináns szeptimakkord esetén az alaphangot adjuk meg, majd egy 7 - es szám következik.Például "A7", "C#7" stb.Ha dúr akkordnév érkezik bemenetként, akkor sorban a következő hangokat tartalmazza a kimenet : alaphang, az alaphang után következő 4. hang és az alaphang után következő 7. hang.Ha domináns szeptimakkordról van szó, akkor a kimeneti sorrend : alaphang, az alaphang után következő 4. hang, az alaphang után következő 7. hang és az alaphang után következő 10. hang.

For example :

Test Result
cout << getNotes("F");
F A C

---------------------------------------

string getNotes(string chord) {
    string hangok;
    string skála = "C C# D D# E F F# G G# A A# B";
    string alaphang = chord.substr(0, chord.length() - 1);
    int oktávKorrekció = 0;

    if (chord[chord.length() - 1] == '7') {
        hangok += alaphang + " ";
        chord = chord.substr(0, chord.length() - 1);
        oktávKorrekció = 3; // Domináns szeptimakkordhoz tartozó korrekció
    }

    size_t alaphangIndex = skála.find(alaphang);
    if (alaphangIndex != string::npos) {
        hangok += skála.substr(alaphangIndex, 2) + " ";
        hangok += skála.substr(alaphangIndex + 4, 2) + " ";
        hangok += skála.substr(alaphangIndex + 7 + oktávKorrekció, 2) + " ";
    }

    return hangok;
}

Feladat
Készítsen string getNotes(string chord) függvényt, ami egy paraméterül kapott akkord nevéről eldönti, hogy milyen hangokból épül fel és ezeket egy string - be fűzve, szóközzel elválasztva visszaadja.A zenei hangok sorban a következők lehetnek : "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#" vagy "B".A hangok sorban egymást követik, olyan módon, hogy a "B" hang után ismét "C" következik, majd "C#", és így tovább.A függvénynek két fajta akkordot kell felismernie : dúr akkord és domináns szeptimakkord.A dúr akkord neve csak az alaphangjából áll, ami tetszőleges hang lehet a felsoroltak közül.Például : "A", "C#" stb.A domináns szeptimakkord esetén az alaphangot adjuk meg, majd egy 7 - es szám következik.Például "A7", "C#7" stb.Ha dúr akkordnév érkezik bemenetként, akkor sorban a következő hangokat tartalmazza a kimenet : alaphang, az alaphang után következő 4. hang és az alaphang után következő 7. hang.Ha domináns szeptimakkordról van szó, akkor a kimeneti sorrend : alaphang, az alaphang után következő 4. hang, az alaphang után következő 7. hang és az alaphang után következő 10. hang.

For example :

Test Result
cout << getNotes("F");
F A C


Feladat
Készítsen void printGantt(int s[], int e[], int n) függvényt, amely gantt diagram megjelenítésére alkalmas. A diagram n darab tevékenységet tartalmaz, ahol az egyes tevékenységek kezdő, legelső időszakát az s tömb, a befejező, legutolsó időszakát az e tömb tartalmazza. Most az nincs meghatározva, hogy az időszakok milyen mértékegységet jelentenek (pl. nap, hét, hónap), a megjelenítés tekintetében nincs jelentősége.

Az egyes tevékenységeket egymás alatt jelenítse meg a következők szerint. Minden sor az "x. feladat" szöveggel kezdődik, ahol x az adott feladat sorszáma. A listában a legelső sorszáma 1, a következőé 2, és így tovább. Maximum 99 feladatra kell felkészülni és a sorszámot minden esetben két karakter hosszan jelenítse meg, ahol a kitöltő karakter a szóköz legyen. A feladat nevét és a hozzá tartozó időtartomány megjelenítését egy " | " karaktersorozat választja el. Ez után "█" karakterek segítségével vizualizálja a tevékenységhez tartozó időtartományt, ahol egy időegység egy karakternek felel meg.

For example:

Test Result
int s[] = {1, 4, 10};
int e[] = {5, 15, 12};
printGantt(s, e, 3);
1. feladat | █████
2. feladat | ████████████
3. feladat | ███

---------------------------------------

Feladat
Készítsen void printForm(string header[], int rows, int cols) függvényt, amely nyomtatásra készít elő egy táblázatot.

A függvénynek egy táblázatot kell a kimenetre rajzolnia. A táblázat fejlécének feliratait a header tömb tartalmazza, melynek elemszáma cols és egyben ennyi oszlopa legyen a táblázatnak.

A fejléc után rows darab sornak kell következnie, melyek egyenként cols darab üres cellát tartalmaznak. A táblázat szegélyét "|" és "-" karakterekből rajzolja a kimenetre, a minta szerinti elgondolás alapján.

A táblázat cellái ugyanolyan méretűek, ahol a szélesség a következő szerint kerüljön meghatározásra. Vegye a leghosszabb fejlécszöveget és annak hosszát 2-vel növelve kapja meg a cellák szélességét.

Az egyes fejlécszövegeket középre igazítva jelenítse meg. Ha az adott fejlécszöveg karakterszáma miatt nem lehetséges pontosan középre igazítani, akkor a szöveg előtt legyen eggyel több szóköz.

A fejléc szövege csak az angol ábécé karaktereit és szóközt tartalmazhat és a táblázatnak mindig van legalább 1 fejléce.

For example:

Test Result
string header[] = {"ID", "Surname", "Given name", "E-mail"};
printForm(header, 5, 4);
-----------------------------------------------------
| ID | Surname | Given name | E-mail |
-----------------------------------------------------
|    |         |            |        |
-----------------------------------------------------
|    |         |            |        |
-----------------------------------------------------
|    |         |            |        |
-----------------------------------------------------
|    |         |            |        |
-----------------------------------------------------
|    |         |            |        |
-----------------------------------------------------


---------------------------------------

void printForm(vector<string> header, int rows, int cols) {
    // Szélesség meghatározása a leghosszabb fejlécszöveg alapján
    int maxHeaderWidth = 0;
    for (const string& text : header) {
        int width = text.length();
        if (width > maxHeaderWidth) {
            maxHeaderWidth = width;
        }
    }
    int cellWidth = maxHeaderWidth + 2;

    // Táblázat nyomtatása
    int totalWidth = (cellWidth + 1) * cols + 1; // Táblázat teljes szélessége
    string horizontalLine(totalWidth, '-'); // Táblázat fejlécét és sorait elválasztó vízszintes vonal
    string emptyCell(cellWidth, ' '); // Üres cella

    // Fejléc nyomtatása
    cout << horizontalLine << endl;
    for (const string& text : header) {
        int padding = (cellWidth - text.length()) / 2;
        cout << "|";
        for (int i = 0; i < padding; i++) {
            cout << " ";
        }
        cout << text;
        for (int i = 0; i < padding + (cellWidth - text.length()) % 2; i++) {
            cout << " ";
        }
    }
    cout << "|" << endl;
    cout << horizontalLine << endl;

    // Üres sorok nyomtatása
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << "|" << emptyCell;
        }
        cout << "|" << endl;
        cout << horizontalLine << endl;
    }
}

Feladat

Készítsen void drawRect(int **m, int w, int h, struct rect rects[], int num_of_rects) függvényt, amelynek segítségével szürkeárnyalatos képeket lehet rajzolni. A bemeneti m két-dimenziós tömb jelentsen egy w széles (első koordináta) és h magas (második koordináta) képet. Erre a képre szeretnénk num_of_rects darab téglalapokat rajzolni, melyek paraméterei a rects tömbben találhatók. Egy struct rect tárolja el egy téglalap bal felső sarkának pozícióját (x, y), a szélességét (w), és a magasságát (h). A téglalapokat rajzolja az m képre olyan módon, hogy ahova a téglalap szélei kerülnek, ott az értéke 1 legyen, ahol a közbülső értékei szerepelnek, ott 0 érték jelenjen meg. Ha két tetszőleges téglalap átfedésben van, akkor az legyen előrébb, amelynek a rects tömbben elfoglalt pozíciójának az indexe kisebb. Az m kép bal felső sarka jelentse a 0. sor és 0. oszlopban található értéket.
For example:

Test Result
int **m = createMap(15, 15);
struct rect rects[] = {{2, 3, 6, 6}, {6, 7, 5, 3}, {4, 1, 10, 12}};
drawRect(m, 15, 15, rects, 3);
printMap(m, 15, 15);

██████████
█ █
██████ █
█ █ █
█ █ █
█ █ █
█ ████ █
██████ █ █
█ █████ █
█ █
█ █
██████████


Feladat
A magyar bankszámlaszámok első három számjegye a számlavezető pénzintézetet kódolja (ún.
GIRO-kód). Definiálja azt a std::string getBank(std::string accno, std::string filename) függvényt,
ami megállapítja, hogy az accno folyószámlát melyik pénzintézetnél vezetik! A filename nevű
állomány egy CSV fájl, melynek két oszlopa van: az első a bank három számjegyű kódját
tárolja, a második a bank nevét. E kettőt pontosvessző választja el. A visszatérési érték a
számlavezető bank neve legyen, ha talál ilyet a fájlban. Ha nem, térjen vissza Unknown bank
üzenettel! A megadott adatokról feltételezheti, hogy formailag helyesek lesznek.
For example:
Test Result
std::cout << getBank("66600000-00000000", "bank1.csv") << std::endl;
Unknown bank
std::cout << getBank("18112345-12345678", "bank1.csv") << std::endl;
Allianz Bank Zrt.
Answer:(penalty regime: 0 %)

Feladat
Banki átutalás során ma már nem csak egy adott számlaszámra lehet utalni, hanem ún.
másodlagos azonosítók (e-mail cím, mobiltelefonszám, adószám, adóazonosító jel) alapján is.
Egy bankszámlaszámot, és a hozzá társított másodlagos azonosítókat egy irányban láncolt
listában tároljuk, a listaelem szerkezetét pedig már előzetesen definiáltuk a következőképpen:
struct account {
std::string accountNo;
std::string email;
std::string mobile;
std::string taxNo;
std::string taxId;
account* next;
};
Definiálja azt az account* append(account* anchor, std::string accountNo, std::string email,
std::string mobile, std::string taxNo, std::string taxId) függvényt, ami a lista végéhez hozzáfűzi a
megadott azonosítókból álló listaelemet, ha minden azonosító egyedi, majd visszatér a lista
horgonyával (első elemének címével).
For example:
Test Result
account* a1 = nullptr;

a1 = insertFirst(a1, "33333333-33333333", "3@bank.hu", "+36 333-3333", "33333333-3-33",
"3333333333");
a1 = insertFirst(a1, "22222222-22222222", "2@bank.hu", "+36 222-2222", "22222222-2-22",
"2222222222");
a1 = insertFirst(a1, "11111111-11111111", "1@bank.hu", "+36 111-1111", "11111111-1-11",
"1111111111");
a1 = append (a1, "44444444-44444444", "4@bank.hu", "+36 444-4444", "44444444-4-44",
"4444444444");
print(a1);
freeMem(a1);
11111111-11111111/1@bank.hu/+36 111-1111/11111111-1-11/1111111111
22222222-22222222/2@bank.hu/+36 222-2222/22222222-2-22/2222222222
33333333-33333333/3@bank.hu/+36 333-3333/33333333-3-33/3333333333
44444444-44444444/4@bank.hu/+36 444-4444/44444444-4-44/4444444444
Answer:(penalty regime: 0 %)

Feladat
A magyar bankszámlaszámok két vagy három, egyenként nyolc számjegyből álló blokkokból
tevődnek össze, melyeket kötőjelek választanak el egymástól. A számlaszámokat beépített
ellenőrző számjegyek védik a véletlen elgépelések okozta hibáktól. Az első blokk első hét
számjegyének hibáit fedi fel a blokk utolsó számjegye, ami ennek a blokknak az ellenőrző
számjegye. Ha csak két blokk van, akkor a második blokk utolsó számjegye is ellenőrző
számjegy, ami a második blokk első hét számjegyének hibáit segít felfedni. Ha azonban három
blokkból áll a számlaszám, akkor a második blokk összes számjegyéből, és a harmadik blokk
első hét számjegyéből álló részét védi a legutolsó helyértéken álló ellenőrző számjegy.
Az ellenőrző számjegyeket úgy képezik, hogy az első blokk elemeit balról jobbra haladva
megszorozzák 9, 7, 3, 1, 9, 7, 3 számokkal és a szorzatokat összeadják. Az ellenőrző
számjegyet a 10-zel maradék nélkül osztható összegre történő felkerekítés értéke adja.
Alapvetően ugyanilyen módon számolják a második ellenőrző összeget is, de ha három
blokkból áll a számlaszám, akkor a 9, 7, 3, 1 szorzókat egymás után többször is alkalmazzák.
Példa: Ellenőrizzük a 49876264-83796278-93836965 bankszámlaszámot!
Az első nyolc számjegy ellenőrzése: 9x4, 7x9, 3x8, 1x7, 9x6, 7x2, 3x6 ezek összeadva 216.
Ennek felkerekítéséhez a következő 10-zel maradék nélkül osztható számra (220-ra) 4
szükséges, az ellenőrző szám tehát 4. Vagyis a bankszámlaszám első nyolcas csoportja
szabályos.
A második nyolc számjegyet ugyanígy kell ellenőrizni kétszer nyolc jegyű számlaszám esetén.
Háromszor nyolc jegyű számlaszámnál viszont a második nyolcas csoport végén folytatni kell a
9, 7, 3, 1-gyel való szorzást a harmadik nyolcas csoport végéig, így 15 ilyen szorzatot fogunk
összeadni. A fenti példában 9x8, 7x3, 3x7, 1x9, 9x6, 7x2, 3x7, 1x8, 9x9, 7x3, 3x8, 1x3, 9x6, 7x9,

3x6 szorzatait összeadva 484-et kapunk. Ezt a 10-zel maradék nélkül osztható legközelebbi
számhoz (490) felkerekítve 6-ot kapunk, ez tehát az ellenőrző szám.
Mivel a fenti példában az utolsó helyen nem 6-os szám áll, ezért a bankszámlaszám nem
szabályos.
(Forrás)
Definiálja azt a bool account(std::string accno) függvényt, ami akkor és csak akkor ad vissza
igaz értéket, ha az átadott számlaszám formailag is megfelelő, és az ellenőrző számjegyek is
megfelelő értékűek.
For example:
Test Result
std::cout << (account("49876264-83796278-93836965")?"Valid":"Invalid") << std::endl;
Invalid
std::cout << (account("10032000-01076019")?"Valid":"Invalid") << std::endl;
Valid

Feladat
A Huffman kódolás egy hatékony tömörítő eljárás, mely változó hosszúságú prefix kódokkal
helyettesíti az adatforrás karaktereit. A prefix kód azt jelenti, hogy egyetlen karakterhez rendelt
kód sem kezdődik valamely másik karakter kódjával, és nem is egyezik meg azokkal (különben
a tömörített adat nem lenne visszafejthető). Definiálja azt a bool isValid(huffman* table, int n)
függvényt, amelynek table paramétere egy huffman típusú struktúrákból álló, n elemű tömb. A
struktúra már definiált a következőképpen:
struct huffman {
char letter;
std::string code;
};
A függvény visszatérési értéke akkor és csak akkor igaz, ha a struktúratömb minden kódjára
teljesül a prefix tulajdonság.
For example:
Test Result
huffman t1[] = {
{ ' ', "011" },
{ 'a', "1" },
{ 'f', "0000" },
{ 'l', "001" },
{ 'm', "0001" },
{ 't', "010" }
};
int n1 = sizeof(t1)/sizeof(t1[0]);
std::cout << (isValid(t1, n1)?"Valid":"Invalid") << std::endl;
Valid
huffman t3[] = {
{ ' ', "111" },
{ 'a', "0" },
{ 'f', "100" },
{ 'l', "101" },
{ 'm', "1001" },
{ 't', "110" }
};
int n3 = sizeof(t3)/sizeof(t3[0]);
std::cout << (isValid(t3, n3)?"Valid":"Invalid") << std::endl;
Invalid

Feladat
Definiálja a Number* arithmetic Progression (double al, double d, int n) függvényt, ami n listaelemből álló, két irányban láncolt listát hoz létre az a1 kezdő taggal rendelkező, d
differenciájú számtani sorozat első n tagjának tárolására! (A teszt során a tagokat oda-vissza kiírjuk, hogy ellenőrizzük a láncolás helyességét.)
A Number struktúra már definiált a következőképpen, ezzel nem kell külön foglalkoznia:
struct Number {
};
double value;
Number* next;
Number* prev;
For example:
Test
Result
printForwardReverseFree (arithmetic Progression (1, 2, 3)); 1 3 5 3 1
Answer: (penalty regime: 0%)
1

Feladat
Készítse el azt a void total (const Product* p, int n) függvényt, ami a Product típusú elemekből álló, n elemű struktúratömb elemeit dolgozza fel! A struktúra már előzetesen definiált a következőképpen:
struct Product {
};
std::string name; int pcs;
A struktúra egy termék nevét (name) és darabszámát (pcs) tartalmazza. A struktúra tömb olyan struktúrákból áll, melyek közül akár több is tartalmazhatja ugyanannak a terméknek a nevét, akár eltérő darabszámokkal. A függvény feladata összegezni az egyes termékekből rendelkezésre álló mennyiségeket, és olyan sorrendben megjeleníti az eredményt a szabvány kimeneten, amilyen sorrendben a termékek először felbukkantak a tömbben.
For example:
Test
Product p[] = {
Result
alma 7
{"alma", 3},
barack 3
{"barack", 2},
citrom 1
{"alma", 4},
{"citrom", 1},
};
{"barack", 1}
int n = sizeof(p)/sizeof(*p);
total(p, n);

Feladat
Definiálja a ListItem* splitter (const std::string& text, char separator) függvényt, ami a separator karakterek mentén több szóra bontja a text szöveget, és az így előálló szavakat a ListItem típusú, előzetesen már definiált struktúrákból álló, egy irányban láncolt listában helyezi el. A visszatérési érték a lista horgonya legyen! A listaelem szerkezete a következő:
struct ListItem {
};
std::string word;
ListItem* next;
For example:
Test
printAndDelete(splitter("This is the beginning of a beautiful friendship.",
')); >


Feladat
Definiálja a void printGantt (int mtx[][2], int n) függvényt, ami egyszerűsített (csak a feladatok időbeli ütemezését megjelenítő) Gantt diagrammot nyomtat a szabványos kimenetre! Az n sorból és 2 oszlopból álló mtx mátrix minden sora megadja, hogy a diagram sávjai a képernyő milyen indexű oszlopában kezdődnek és fejeződnek be (tehát ezek zárt intervallumok).
For example:
Test
Result
int mtx[][2] = {
****
*****
{0, 3},
*******
{1, 5},
{3, 9}
};
int n = sizeof(mtx)/sizeof(mtx[0]);
printGantt (mtx, n);

Feladat
Definiálja a void center (const std::string& fileName) függvényt, ami megkeresi a fileName nevű szövegfájl leghosszabb sorát, majd ilyen széles oszlopban középre igazítva kinyomtatja valamennyi sor tartalmát. Ha a középre igazítás során nem lehet pontosan ugyanannyi szóközt hagyni a sor előtt és mögött, akkor előtte legyen eggyel kevesebb!
For example:
Test
Result
center("file1.txt"); A
AA
AAA
AAAA
AAAAA
AAAAAA


Feladat
Már definiáltuk a
struct adat {
};
int szam;
adat* kov;
struktúrát egyszeresen láncolt lista létrehozásához. Készítse el azt az adat* parosTorol (adat* horgony) függvényt, ami kitörli a listából azokat az elemeket, melyek szam tagja páros számot tárol. A visszatérési érték a módosított lista horgonya legyen!
For example:
Test
Result
{
13
adat* h = nullptr;
beszur (h, 3);
}
beszur (h, 2);
beszur (h, 1);
h = parosTorol(h);
kiir(h);
felszabadit(h);

Feladat
A szoftverek számos helyen alkalmazzák (a C++ pl. a szimbolikus állandóknál) az ún. screaming snake case névkonvenciót. Ez abból áll, hogy a több szóból összetett azonosítók szavait csupa nagybetűvel írják, egymástól karakterrel elválasztva.
Definiálja azt a string screaming(string* szavak, int n) függvényt, ami az n elemű szavak string tömb elemeit (szavait) felhasználva előállít egy screaming snake case azonosítót, amit visszaad.
For example:
Test
{
string s[] = {"I", "love", "C++", "programming"}; int n = sizeof(s)/sizeof(s[0]);
Result
I_LOVE_C++ PROGRAMMING
cout << screaming (s, n) << endl;
}

Feladat
Definiált két struktúra a következőképpen:
struct color {
unsigned char r;
unsigned char g;
unsigned char b;
};
struct weight {
};
double r;
double g; double b;
Valósítsa meg azt az unsigned char color2gs (const color& c, const weight& w) függvényt, ami átalakítja a c paraméterben érkező, RGB összetevőivel adott színt egyetlen szürkeskálás értékké, figyelembe véve a w paraméterben adott súlyokat. Például, a BT-709 szabvány szerinti súlyokkal, melyeket a HDTV-k használnak, a szürkeskálás fényerősség érték kiszámítása a következőképpen történik:
gs = 0.21*r + 0.72*g + 0.07*b
For example:
Test
weight bt709
==
(0.21, 0.72, 0.07};
cout << (int) color2gs({100, 100, 100), bt709) << endl;
Result
100

Feladat
Definiálja azt a void mbox (const string& message) függvényt, ami a paraméterként adott message szöveget csillagokból rajzolt szövegdoboz belsejében, balra igazítottan jeleníti meg! Amennyiben az üzenet soremelés karaktert tartalmaz, a nyomtatást a következő sorban kell folytatni!
For example:
Test
Result
mbox("ab\ncde\nf");
ab *
*cde*
*f
*
*****

Feladat
Definiálja azt az int** vek2mtx(int* vek, int s, int o) függvényt, ami a neki átadott, sxo elemszámú vek tömb elemeiből előállít és visszaad egy mátrixot, melynek futásidőben, dinamikusan foglal tárhelyet. A mátrix sorainak száma s, oszlopainak száma o legyen!
For example:
Test
Result
{
const int s = 2;
const int o = 3;
int v[] = {11, 12, 13, 21, 22, 23);
int** m = vek2mtx(v, s, 0);
print(m, s, 0);
felszabadit (m, s);
}
11 12 13
21 22 23

Feladat
Valósítson meg bool friendly_numbers(int a, int b) függvényt. A függvény feladata annak eldöntése, hogy a és b barátságos számpárt alkotnak vagy sem, és ennek megfelelő logikai értékkel térjen vissza. Két szám akkor tekinthető barátságosnak, ha mindkettő esetén fent áll, hogy önmagánál kisebb osztóinak összege megegyezik a másik számmal.
Pl. 220 és 284 barátságos számpár, mert 220 osztóinak összege: 1+2+4+ 5+10+11 + 20 +22+44 +55 +110 = 284, és 284 osztóinak össze: 1 + 2 + 4 + 71 + 142 = 220.
For example:
Test
Result
cout<<< friendly_numbers (228, 284); 1
For example: Test
Result
cout << check("17501021236"); 1

Feladat
Készítsen void diagram(int* data, int n) függvény, ahol data egy n elemú tömb, melynek elemszáma legalább 1 és minden értéke legalább 0. A függvény a data tartalmát egy oszlopdiagram formájában rajzolja a kimenetre a következők szerint. Az
oszlopok 'X' karakterekből épüljenek fel, ahol minden oszlop két karakter széles. Az adott oszlop magassága egyezzen meg a data ábrázolni kívánt elemének értékével. Minden oszlop előtt legyen két szóköznyi üres terület (az első előtt is).
For example:
Test
Result
XX
int data[]= {1, 2, 2, 3, 1); diagram(data, 5);
XX XX XX xx xx xx xx xx

Feladat
Készítsen bool check(string id) függvényt, amely alkalmas személyi azonosító számsorozat ellenőrzó számjegyének ellenőrzésére. A bemeneti id egy string, amely a személyi azonosítót tartalmazza. A személyi azonosító 11 darab egyjegyű szám, ahol az utolsó érték egy ellenőrző számjegy, ami a többi 10 számjegyból számítható. A függvény visszatérési értéke egy logikai érték legyen, ami tartalmazza, hogy az id utolsó számjegye helyes vagy sem. Az utolsó, ellenőrző számjegy a következő módon számítható:
Valósítson meg struct time struktúrát, ami nap, óra, perc és másodperc formában kifejezett idó tárolására alkalmas. Minden értéket egész számként szeretnénk tárolni és az egyes tagok neve a következő legyen: days, hours, minutes, seconds. Hozzon létre struct time get_time(int s) függvényt, ahol s egy másodpercben kifejezett idő érték. Ezt alakítsa át nap, óra, perc, másodperc formátumba, és egy ennek megfelelő time struktúrával térjen vissza.
For example:
Test
Result
print_time(get_time (100)); minutes: 1
seconds: 40


Feladat
Valósítson meg bool luxor(int* ticket, int n) függvényt, ahol ticket egy n elemú tömb. A függvény határozza meg, hogy ticket egy helyes Luxor szelvény tippjeit tartalmazza vagy sem. Ennek megfelelő logikai értékkel térjen vissza. A Luxor játékban az [1, 75] intervallumból kell összesen 20 számot megjelölni, úgy, hogy a számok 5 egyenlő, nem átfedó intervallumra vannak osztva és minden intervallumból 4-4 számra kell tippelni.
For example: Test
int ticket[] = {1, 2, 3, 4, 16, 17, 18, 19, 31, 32, 33, 34, 46, 47, 48,
49, 66, 67, 68, 69};
cout << luxor (ticket, 20);
Result
ahol
a személyi azonosító utolsó számjegye és számjegye.
a személyi azonosító -edik
Feltételezheti, hogy id mindig 11 jegyű és csak számokat tartalmaz.

Feladat
A legtöbb európai termékre, melyekre hely hiányában csak egy rövid vonalkódot tudnak elhelyezni, az EAN- 8 szabványnak megfelelő vonalkód kerül. Ez nevének megfelelően 8 számjegyból áll, melyek közül az utolsó egy ellenőrző számjegy. Ennek segítségével lehet észrevenni, ha egy számjegyet hibásan adtak meg vagy olvastak le. Az ellenőrzó számjegyet úgy számítják ki, hogy az első 7 számjegy közül minden páros indexút 3-mal szoroznak be, minden páratlan indexút pedig 1-gyel, majd veszik ezeknek a szorzatoknak az összegét. Ennek az összegnek az utolsó számjegyét kivonják 10-ból, ez lesz az ellenőrző számjegy. Ha ez pont 10-re adódna, helyette 0-t használnak.
Definiálja azt a beansCheck(const strings barcode) függvényt, ami akkor és csak akkor tér vissza logikai igaz értékkel, ha a paraméterként adott vonalkód minden szempontból helyes, azaz
• pontosan 8 számjegy karakterből áll,
⚫ és az ellenőrzó számjegy értéke megfelelő.

Feladat
Definiálja azt a void justifiatcine wardal], int n, int width) függvényt, mely
az n elemú words, tömbben szereplő szavakat width szélességben nyomtatja ki egymás mellé, sorkizárt igazítással! Ez konkrétan azt jelenti, hogy
⚫ a szavak közé úgy kell elhelyezni a szóközöket, hogy a szavak az elválasztó jelekkel együtt pontosan width szélességet adjanak ki.
• Az egymást követő szópárokat elválasztó jelek számának amennyire lehet, azonosnak kellene lennie, de tört számú szóközt nem lehet megjeleníteni. Ha arra szükség van, az első néhány szó között legyen eggyel több szóköz, mint a későbbi szavak között.
Nem kell felkészülnie olyan határhelyzetek kezelésére, mint pl.
⚫ kettőnél kevesebb szó (akkor nem lehetne a szavak közé tenni az elválasztó jeleket),
⚫ olyan alacsony width érték, amelynél lehetetlen a szavakat akár csak egyetlen elválasztó jellel is megjeleníteni.

Feladat
Definiálja azt az int wordCount(const string text) függvényt, ami megszámolja a text szövegben lévő szavakat, és visszatérési értékében szolgáltatja az eredményt! Vegye figyelembe, hogy a szavakat szóközök, tabulátor és új sor karakterek is elválaszthatják egymástól, valamint egymás mellett akár több ilyen elválasztó jel is állhat.